<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Gallon Yin"><meta name="description" content="A place full of miracless"><title>Gallon's World</title><link rel="icon" href="/website.ico"><link rel="canonical" href="http://gallonyin.github.io/"><link rel="alternate" href="/atom.xml" title="Gallon's World"><link rel="stylesheet" href="/css/style.css"><script type="text/javascript">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?Your baidu Analytics ID";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'Your Google Analytics ID', 'auto');
ga('send', 'pageview');</script></head><body><div id="main"><header><a href="/." class="logo">Gallon's World</a><ul class="nav"><li class="nav-link"><a href="/" class="active">Home</a></li><li class="nav-link"><a href="/archives/" target="_self">Archives</a></li><li class="nav-link"><a href="/categories" target="_self">Categories</a></li><li class="nav-link"><a href="/about/" target="_self">About</a></li></ul></header><section id="container"><ul class="home"><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2017/04/23/Git/" class="post-link">Git 版本控制系统规范</a></h2><span class="post-time">Apr 23, 2017</span><div class="post-content"><p>####我们为什么选择 Git<br>目前如果你如果进行项目开发有一定规范，那么肯定会使用版本控制系统(Version Control System)，目前比较流行两个就是 SVN 和 Git。Git有很多优点，其中很显著的一点，就是版本的分支(branch)和合并(merge)十分方便，相对也占用更少的硬盘空间。</p>
<p>####我们的管理规范<br>我们公司使用了 Git + YouTrack 配合进行版本控制，我先简单说一下我们现在的流程规范(如果你还没用过 Git 可以跳过)。</p>
<p>首先，我们有一个主分支 Master，这里只有稳定的可用版本，Master 上的每个版本就是拿来可以用的对应版本号的发布版本(含已发布版本和待发布版本)，Master 是不允许随意改动的。</p>
<p>第二，从 Master 唯一新建分支，开发分支 Develop，该项目所有开发者在完成新模块或修复异常等一个具体任务后，可以合并到 Develop 进行联合测试。</p>
<p>第三，从开发分支 Develop，以开发者名新建分支，如 gallon、sfs、jksfood 等，作为单个开发者的开发分支。</p>
<p>第四，从自己的开发分支(如 gallon)再新建分支(该分支通过 Android Studio 内置的 YouTrack 就会自动提示创建一个任务分支，前提是 AS 的 Git 要和远端仓库关联起来)，现在只要把一个个 Task 任务发布到 YouTrack 就可以了，当这个任务完成后，需要你把任务分支合并到自己的分支(gallon)，自己运行可以跑通(通常这里不会有任何问题，因为理论上 gallon 是一直低于任务分支版本的)之后再提交到 develop 分支上，让 Android 组长或负责人或测试人员去检验，如果没有问题到此这个任务就算是 done 了。</p>
<p>####我自己的使用感受<br>以上看起来步步都很清晰，你在什么阶段在什么分支上做什么事，但是，我们来想这么一个情况，如果我有两个 Task 但是他们有很多重叠代码，我可以去同时做这两个任务，但是根据管理规范你只应该在一个分支上专注你的那个 Task，而且领导只知道看 YouTrack 上已经确定好的一条条任务给你做绩效评定呢，结果新建了两个任务分支 A 和 B，你猜的到的，效率会非常低，但是也有一点好处，你能更加专注的做好这一个任务，想想规范一些也不错，那么还有另外一种情况，突然又有新的需要优先去处理的 Task，你需要先把当前的任务分支本地提交，注意，这时因为该任务没完成，我们通常不会把这个任务分支 A 合并到 gallon 分支(正确的做法是该任务完成后合并)，然后切换到 gallon 分支，然后创建新任务分支 B，这时候 B 是落后 A 版本的，你在分支 A 中修改的代码都不能在分支 B 中看到，但如果有些你需要用到的代码，是的，要么在 B 中重新写一份(可能还是要小小的解决一下冲突)，要么等两个任务都完成了，合并后再修改重叠部分，如果有些情况你常常要在任务分支 A 和任务分支 B 跳来跳去，那可能结果是你要不停解决你自己的冲突，听起来是不是很好笑？好吧，我可能是做惯了多线程操作，常常同一时间做几个任务，修复一个小异常或调整布局与开发新功能同时在编译安装的时候进行等。这种规范对我的编程可以说是加了限制。</p>
<p>但是，我仍然觉得这种规范是很有道理和有必要的，虽然刚开始使用看起来步骤繁多，甚至可能是稍微降低效率的，可是这种规范对任务的正常的推进依然起到了非常重要的作用，对安全性也提供了很大的保证。以后我会建议分配到个人的多个小任务也可以写到一个 Task 当中去，这样也在保证这种规范的情况下，更好的提高效率嘛。</p>
<p>然而这样就是最先进的或最规范的管理方法了吗？我不知道，有的公司是没有我提到的个人分支的，只需要在 develop 上创建新的任务分支；我之前的公司则是只要在 的velop 上进行开发就行。也许只有适合自己(团队)的，才是最好的。当然，如果你现在连 Git 都还没体验过，肯定是看的一头雾水，赶紧去试试吧！</p>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2017/04/09/Android Study/" class="post-link">Android 修炼手册</a></h2><span class="post-time">Apr 9, 2017</span><div class="post-content"><h4 id="写在前头"><a href="#写在前头" class="headerlink" title="写在前头"></a>写在前头</h4><p>从 0 开始 Android 之路，你如何不断进步？一年半 Android 的小白的自省，因为我最近有可能转做 Java 了所以，回过头看，把自己的经验记录下来，供自己回忆和旁人参考。</p></div><a href="/2017/04/09/Android Study/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2017/03/12/Buffered/" class="post-link">BufferedInput/OutputStream 缓冲流性能测试 [Java]</a></h2><span class="post-time">Mar 12, 2017</span><div class="post-content"><p>首先，一次 IO 的代价是很高的，所以减少 IO 次数将会极大提升性能。提高文件读写性能，是每一位开发者都要考虑的，也是本文的核心目的，如果已经对 Java 中的 IO 流比较熟悉，可以直接拖到最后看结论。</p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>IO 流用来处理设备之间的数据传输，Java 对数据的操作是通过流的方式，用于操作流的类都在 IO 包内，按流向分为输入流，输出流；按流操作分为字节流，字符流，其中字节流可以操作任何数据，因为在计算机中任何数据都是以字节的形式存储，字符流只能操作纯字符数据，比较方便。字节流的抽象父类：InputStream，OutputStream；字符流的抽象父类：Reader，Writer。</p></div><a href="/2017/03/12/Buffered/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2017/02/27/Python Base/" class="post-link">Python 中那些知识点 [持续更新] [Python]</a></h2><span class="post-time">Feb 27, 2017</span><div class="post-content"><p>本文是我在自学 Python 3.5 中遇到的一些知识梳理和一些技巧分享，Python 在简洁性、易读性以及可扩展性上优势明显，使用率呈线性增长，如果你想去学习一门新的设计语言或是开开眼界，那么我非常推荐你这个优美的能写出乐趣的语言 Python<br></div><a href="/2017/02/27/Python Base/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/12/11/BlockingQueue/" class="post-link">阻塞式队列的实现原理 BlockingQueue [Java]</a></h2><span class="post-time">Dec 11, 2016</span><div class="post-content"><h4 id="阻塞式队列的实现方式"><a href="#阻塞式队列的实现方式" class="headerlink" title="阻塞式队列的实现方式"></a>阻塞式队列的实现方式</h4><p>首先，阻塞队列( BlockingQueue )是 Java util.concurrent 包下重要的数据结构。当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满；从阻塞队列取数据时，如果队列已空，线程将会阻塞等待直到队列非空。本文与 java 官方的阻塞式队列不同，自己以另一种方式(线程 wait / notifyAll )实现(原理相似)，本案 demo 遵循 FIFO (先进先出)原则，只写出了 put (阻塞)/ take (阻塞)方法，官方实现还含有 add / remove (失败抛出异常)、offer / poll (失败时返回值不同)、offer / poll (重载 增加 timeout 阻塞时间限制，并返回值是否成功)在这里都没有写出。除此之外 lock / condition 方式实现也附在文中最下方以供对比。本案 demo 使用 Android UI 但是只需懂得 java 基本语法，不会影响理解。<br></div><a href="/2016/12/11/BlockingQueue/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/11/30/Hello Hexo/" class="post-link">Hello Hexo</a></h2><span class="post-time">Nov 30, 2016</span><div class="post-content"></div></article></li></ul><div class="paginator"></div></section><footer><div class="social"><a href="https://github.com/gallonyin" title="github" class="iconfont icon-github"></a></div><div class="copyright"><p class="power">Powered by <a href="https://hexo.io/">Hexo</a> and Theme by <a href="https://github.com/ahonn/hexo-theme-even"> Even</a></p><p class="since">&copy;2016-2017<span class="heart"><i class="iconfont icon-heart"></i></span><span class="author">Gallon Yin</span></p></div><div id="back2top"><i class="iconfont icon-up"></i></div></footer></div><script src="/js/zepto.min.js"></script><script src="/js/theme.js"></script></body></html>