<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Gallon Yin"><meta name="description" content="A place full of miracless"><title>Gallon's World</title><link rel="icon" href="/website.ico"><link rel="canonical" href="http://gallonyin.github.io/"><link rel="alternate" href="/atom.xml" title="Gallon's World"><link rel="stylesheet" href="/css/style.css"><script type="text/javascript">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?Your baidu Analytics ID";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'Your Google Analytics ID', 'auto');
ga('send', 'pageview');</script></head><body><div id="main"><header><a href="/." class="logo">Gallon's World</a><ul class="nav"><li class="nav-link"><a href="/" class="active">Home</a></li><li class="nav-link"><a href="/archives/" target="_self">Archives</a></li><li class="nav-link"><a href="/about/" target="_self">About</a></li></ul></header><section id="container"><ul class="home"><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2017/03/12/Buffered/" class="post-link">BufferedInput/OutputStream 缓冲流性能测试 [Java]</a></h2><span class="post-time">Mar 12, 2017</span><div class="post-content"><p>首先，一次 IO 的代价是很高的，所以减少 IO 次数将会极大提升性能。提高文件读写性能，是每一位开发者都要考虑的，也是本文的核心目的，如果已经对 Java 中的 IO 流比较熟悉，可以直接拖到最后看结论。</p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>IO 流用来处理设备之间的数据传输，Java 对数据的操作是通过流的方式，用于操作流的类都在 IO 包内，按流向分为输入流，输出流；按流操作分为字节流，字符流，其中字节流可以操作任何数据，因为在计算机中任何数据都是以字节的形式存储，字符流只能操作纯字符数据，比较方便。字节流的抽象父类：InputStream，OutputStream；字符流的抽象父类：Reader，Writer。</p></div><a href="/2017/03/12/Buffered/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2017/02/27/Python Base/" class="post-link">Python 中那些知识点 [持续更新] [Python]</a></h2><span class="post-time">Feb 27, 2017</span><div class="post-content"><a id="more"></a>
<h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = &apos;ABC&apos;</div><div class="line">b = a</div><div class="line">a = &apos;XYZ&apos;</div><div class="line">print(b)</div><div class="line">\# &apos;ABC&apos;    b = a 使 b 指向的&apos;ABC&apos;地址，所以 b 没有被修改</div></pre></td></tr></table></figure></p>
<p>转义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">\t 表示一个制表符</div><div class="line">\\ 表示 \ 字符本身</div><div class="line">r&apos;...&apos; 表示不需要转义 但不能表示多行也不能表示包含&apos; 和 &apos;&apos; 的字符串(可用 r&apos;&apos;&apos;...&apos;&apos;&apos; 解决)</div></pre></td></tr></table></figure></p>
<p>编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">如果中文字符串在 Python 环境下遇到 UnicodeDecodeError，这是因为 .py 文件保存的格式有问题。可以在第一行添加注释    </div><div class="line">解决方法为只要在文件开头加入 # -*- coding: UTF-8 -*- 或者 #coding=utf-8</div></pre></td></tr></table></figure></p>
<p>计算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">and or 均有短路计算(类似 Java 中 &amp;&amp; ||)</div><div class="line">因为Python把0、空字符串&apos;&apos;和None看成 False，其他数值和非空字符串都看成 True</div><div class="line">返回结果为计算终止项</div></pre></td></tr></table></figure></p>
<p>集合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">当索引数字为负数时，表示逆序读出 List 中的内容，记住 List 的最后一个空间的编号为 -1 开始</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">单元素 tuple 时有歧义，Python 规定，单元素 tuple 要多加一个逗号 &quot;,&quot;，t = (1,)，多元素 tuple 最后加不加 &quot;,&quot; 结果一样</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1. 有序集合：list，tuple，str和unicode；</div><div class="line">2. 无序集合：set</div><div class="line">3. 无序集合并且具有 key-value 对：dict</div></pre></td></tr></table></figure>
<p>网络<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">POST 请求下面必须加 &#123;% csrf_token %&#125; 否则403(安全) </div><div class="line">跨站请求伪造（英语：Cross-site request forgery）</div></pre></td></tr></table></figure></p>
<p>兼容 (Python 2 &amp; Python 3)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">urllib2-Python 官方基础模块  requests - 强大第三方包</div><div class="line">Python 3.x中 urllib 库和 urilib2 库合并成了 urllib 库</div><div class="line">其中 urllib2.urlopen() 变成了 urllib.request.urlopen()</div><div class="line">urllib2.Request() 变成了 urllib.request.Request()</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">去除了 &lt;&gt;，全部改用 != </div><div class="line">去除 ``，全部改用 repr() </div><div class="line">关键词加入 as 和 with，还有 True, False, None </div><div class="line">整型除法返回浮点数，要得到整型结果，请使用// </div><div class="line">加入 nonlocal 语句，使用noclocal x 可以直接指派外围（非全局）变量 </div><div class="line">去除 print 语句，加入 print() 函数实现相同的功能。同样的还有 exec 语句，已经改为 exec() 函数 </div><div class="line">改变了顺序操作符的行为，例如 x &lt; y ，当 x 和 y 类型不匹配时抛出 TypeError  而不是返回随机布尔值 </div><div class="line">输入函数改变了，删除了 raw_input，用 input 代替</div><div class="line">去除元组参数解包。不能 def(a, (b, c)):pass 这样定义函数了 </div><div class="line">Python3 字符串只有 str 一种类型，但它跟 2.x版本的 unicode 几乎一样</div><div class="line">Python3 去除了 long 类型</div><div class="line">大量模块变动</div></pre></td></tr></table></figure>
<p>内建函数 BIF(built-in functions)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">zip() 函数 可以把两个集合合并成一个集合</div><div class="line">zip([10,20,30], [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]) -&gt; [(10, &apos;a&apos;), (20, &apos;b&apos;), (30, &apos;c&apos;)]</div></pre></td></tr></table></figure></p>
<p>特殊方法(魔术方法)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">特殊方法定义在 class 中，不需要直接调用，某些函数或操作符会调用对应的特殊方法</div><div class="line">用于print的__str__(类似toString)  </div><div class="line">用于len的__len__</div><div class="line">用于cmp的__cmp__  (Py3中已经移除, 需要引入 operator 模块 operator.eq(a, b))</div><div class="line">直接调用实力对象 重写__call__</div><div class="line">__str__()用于显示给用户，而__repr__()用于显示给开发人员</div></pre></td></tr></table></figure></p>
<p>三方模块管理工具<br>    1.easy_install  2.pip 官方推荐,已内置到2.7.9</p>
<p>Exception<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">raise Exception(&quot;&quot;) (类似于 throw)</div></pre></td></tr></table></figure></p>
<p>Database<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Database API  </div><div class="line">https://www.python.org/dev/peps/pep-0249/ #官方接口规范 v2.0 </div><div class="line">访问数据库流程</div><div class="line">1.创建 connection 2.获取 cursor 3.执行命令/处理数据 4.关闭 cursor 5.关闭 connection</div><div class="line">connection 对象支持的方法 </div><div class="line">· cursor() # 使用该连接创建并返回游标</div><div class="line">· commit() # 提交当前事务</div><div class="line">· rollback() # 回滚当前事务</div><div class="line">· close() # 关闭连接</div><div class="line">事务: 访问和更新数据库的一个程序执行单元</div><div class="line">- 原子性：事务中包括的诸操作要么都做，要么都不做</div><div class="line">- 一致性：事务必须使数据库从一致性状态变到另一个一致性状态</div><div class="line">- 隔离性：一个事务的执行不能被其他事务干扰</div><div class="line">- 持久性：事务一旦提交，它对数据库的改变就是永久性的</div><div class="line">开发中使用事务</div><div class="line">· 关闭自动 commit: 设置 conn.autocommit(false) (mysql db 默认 false)</div><div class="line">· 正常结束事务: conn.commit()</div><div class="line">· 异常结束事务: conn.rollback()</div></pre></td></tr></table></figure></p>
<h4 id="Hacks-小技巧"><a href="#Hacks-小技巧" class="headerlink" title="Hacks 小技巧"></a>Hacks 小技巧</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int()函数可以把字符串转换为整数  默认按十进制 第二参数 base=&apos;10&apos;</div><div class="line">中偏函数 int2 = functools.partial(int, base=2) #调用按二进制</div></pre></td></tr></table></figure>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/12/11/BlockingQueue/" class="post-link">阻塞式队列的实现原理 BlockingQueue [Java]</a></h2><span class="post-time">Dec 11, 2016</span><div class="post-content"><h4 id="阻塞式队列的实现方式"><a href="#阻塞式队列的实现方式" class="headerlink" title="阻塞式队列的实现方式"></a>阻塞式队列的实现方式</h4><p>首先，阻塞队列( BlockingQueue )是 Java util.concurrent 包下重要的数据结构。当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满；从阻塞队列取数据时，如果队列已空，线程将会阻塞等待直到队列非空。本文与 java 官方的阻塞式队列不同，自己以另一种方式(线程 wait / notifyAll )实现(原理相似)，本案 demo 遵循 FIFO (先进先出)原则，只写出了 put (阻塞)/ take (阻塞)方法，官方实现还含有 add / remove (失败抛出异常)、offer / poll (失败时返回值不同)、offer / poll (重载 增加 timeout 阻塞时间限制，并返回值是否成功)在这里都没有写出。除此之外 lock / condition 方式实现也附在文中最下方以供对比。本案 demo 使用 Android UI 但是只需懂得 java 基本语法，不会影响理解。<br></div><a href="/2016/12/11/BlockingQueue/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/11/30/Hello Hexo/" class="post-link">Hello Hexo</a></h2><span class="post-time">Nov 30, 2016</span><div class="post-content"></div></article></li></ul><div class="paginator"></div></section><footer><div class="social"><a href="https://github.com/gallonyin" title="github" class="iconfont icon-github"></a></div><div class="copyright"><p class="power">Powered by <a href="https://hexo.io/">Hexo</a> and Theme by <a href="https://github.com/ahonn/hexo-theme-even"> Even</a></p><p class="since">&copy;2016-2017<span class="heart"><i class="iconfont icon-heart"></i></span><span class="author">Gallon Yin</span></p></div><div id="back2top"><i class="iconfont icon-up"></i></div></footer></div><script src="/js/zepto.min.js"></script><script src="/js/theme.js"></script></body></html>