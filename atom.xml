<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gallon&#39;s World</title>
  <subtitle>A place full of miracles</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gallonyin.github.io/"/>
  <updated>2017-04-09T11:06:04.775Z</updated>
  <id>http://gallonyin.github.io/</id>
  
  <author>
    <name>Gallon Yin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android 修炼手册</title>
    <link href="http://gallonyin.github.io/2017/04/09/Android%20Study/"/>
    <id>http://gallonyin.github.io/2017/04/09/Android Study/</id>
    <published>2017-04-09T10:01:00.000Z</published>
    <updated>2017-04-09T11:06:04.775Z</updated>
    
    <content type="html"><![CDATA[<h4 id="写在前头"><a href="#写在前头" class="headerlink" title="写在前头"></a>写在前头</h4><p>从 0 开始 Android 之路，你如何不断进步？一年半 Android 的小白的自省，因为我最近有可能转做 Java 了所以，回过头看，把自己的经验记录下来，供自己回忆和旁人参考。</p>
<a id="more"></a>
<h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><ul>
<li><p><strong>一定要会用「 Google 」而不仅是「 百度 」。</strong>  </p>
<p>常见第一个现象就是一个问题百度搜出来的结果都是千篇一律，转载还算好的，(侵权)抄袭很严重，而且很多知识点根本都没有实践，常常会误导，我如果写博客，自己写的东西一定是自己反复实践过的，把这些宝贵的经验总结出来对后来人有一点帮助，就够了。第二个现象是，百度搜索的结果第一屏总是全是广告，而且，比较隐蔽，体验极差，太多招黑的事情这里就不多描述了。</p>
<p>总之，对于做技术的我来说，就像知名博主 stormzhang 所说的，“ Google + Stackoverflow + GitHub 就再也没有解决不了的问题了，而某种意义上，开发其实主要就是解决问题的能力！”。如果你刚想尝试，发现用不了 Google 搜索，那么你需要学会一件事：用「 百度 」帮助你去学会怎么使用「 Google 」，就像新的 windows 系统，第一件事总是用「 IE 」去下载新的浏览器。</p>
</li>
<li><p><strong>一定要去学英文，并且打心底去拥抱她。</strong></p>
<p>很多人并不是学会不会英语，编程都会，英语学不会？但是如果从学校出来之后英语基础没打好，可能对英文网站更有一种恐惧感、厌恶感，不愿意去看去学，其实大家英语都会有点基础，我们所接触的英文网站(如 github、stackoverflow)上也不会有那么多难懂的单词句子。我推荐点办法：如果一句话有很多不懂的单词，那么就把每个单词都查询一下，再把句义推出来；如果一句话只有一两个不懂的单词，那么先试着推理一下句义，其实很可能你已经知道单词的意思了；如果一句话单词你都知道了，但是句义不清楚，没有捷径，对着翻译多看，既然每天工作都这样坚持看英文，相信我，进步速度是非常非常快的。当然还有很多其实大学就过了四六级的同学，那你们的压力更要小的多，只是愿不愿意的问题，我的答案是当然愿意！</p>
</li>
<li><p><strong>一定要在发现问题的时候有深入研究的意愿。</strong></p>
<p>你在自己的项目中有没有遇到是棘手的问题？你是真的发现了问题的根源还是只是”让问题不再复现”？如果某个依赖框架总是报一个莫名其妙的异常，你是否会面对源码排查？很明显，有些问题没有绝对正确的答案，这个项目可能很急，也可能处于各种因素的考虑，需要快速的修复，但是我们作为技术人，要总是有种时时想去深入研究一下的愿望，解决后的成就感是不言而喻的，即使没有解决，你的时间也肯定没有浪费，看过这个框架的源码，设计思想，对你来说一定是一次宝贵的学习机会，这在前期更为重要。如果自己的任务完成，也许有空还可以帮助别人解决 bug，贡献他人是世上少有的增加幸福感的事之一，同事、交流群、活跃的社区，你一定发现过别人的求助，你当时是什么态度呢？</p>
</li>
<li><p><strong>一定要在自己的产品或项目中想方设法持续做优化。</strong></p>
<p>问题没有发现，可能是你不懂测试，有时候看起来一样的 APP 实际的质量差距非常大，很多低级和高级工程师的差距也会在这些过程中有差距。页面数据加载更合理；内存优化更好；配置参数找到平衡点等。可以通过学习 github 上别人写的框架；使用一些内存泄漏检测工具，如「 LeakCanary 」；了解图片的缓存和色彩模式(Android 中的图片加载绝对是个大骨头)。</p>
</li>
<li><p><strong>一定要留一些时间去写或看工作外的项目。</strong></p>
<p>你的产品或项目不可能总会用最新的最热的框架，甚至可能是有点落后的，但是并不一定你想换就能换，这中间问题就很多，稳定性，兼容性，team work，学习/风险成本等，但是这不能成为你自己止步不前的借口， 想要更快速的成长，你必须有所行动，勇于去尝试新的技术，了解先进的项目在用些什么，这样即使你以后有更好的升职或跳槽机会，幸运女神也会给你更多的眷顾。</p>
</li>
<li><p><strong>一定不要放弃阅读。</strong></p>
<p>你可以有很多兴趣爱好，因为时间总是有限的，在现状下其实只能列个清单，排出个优先级，但是，阅读请一定要保持下去。可以是技术相关的，JVM、数据结构、操作系统，也可以是非技术相关的，小说、心理学、经济学、哲学、传记、励志鸡汤等都可以广泛涉猎，万一以后你用上了呢？一点也没用上，我相信也会开拓你的视野，提升你的品味吧，这些可能在你的工作中很难了解到。现在公众号、各种移动社区也都有非常好的资源，我们可以更好的利用我们的碎片化时间，比如阅读。久而久之，必定有所提升。</p>
</li>
<li><p><strong>一定不要放弃运动。</strong></p>
<p>其实我没什么资格说的。基本每天的运动量就是上下班走的一段路，每天平均八千步吧，但是，为了我们的健康，还是要更多运动，共勉。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写在前头&quot;&gt;&lt;a href=&quot;#写在前头&quot; class=&quot;headerlink&quot; title=&quot;写在前头&quot;&gt;&lt;/a&gt;写在前头&lt;/h4&gt;&lt;p&gt;从 0 开始 Android 之路，你如何不断进步？一年半 Android 的小白的自省，因为我最近有可能转做 Java 了所以，回过头看，把自己的经验记录下来，供自己回忆和旁人参考。&lt;/p&gt;
    
    </summary>
    
      <category term="成长" scheme="http://gallonyin.github.io/categories/%E6%88%90%E9%95%BF/"/>
    
    
  </entry>
  
  <entry>
    <title>BufferedInput/OutputStream 缓冲流性能测试 [Java]</title>
    <link href="http://gallonyin.github.io/2017/03/12/Buffered/"/>
    <id>http://gallonyin.github.io/2017/03/12/Buffered/</id>
    <published>2017-03-12T13:15:00.000Z</published>
    <updated>2017-04-09T10:47:28.797Z</updated>
    
    <content type="html"><![CDATA[<p>首先，一次 IO 的代价是很高的，所以减少 IO 次数将会极大提升性能。提高文件读写性能，是每一位开发者都要考虑的，也是本文的核心目的，如果已经对 Java 中的 IO 流比较熟悉，可以直接拖到最后看结论。</p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>IO 流用来处理设备之间的数据传输，Java 对数据的操作是通过流的方式，用于操作流的类都在 IO 包内，按流向分为输入流，输出流；按流操作分为字节流，字符流，其中字节流可以操作任何数据，因为在计算机中任何数据都是以字节的形式存储，字符流只能操作纯字符数据，比较方便。字节流的抽象父类：InputStream，OutputStream；字符流的抽象父类：Reader，Writer。</p>
<a id="more"></a>  
<h4 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h4><p>由于已知减少 IO 次数可以大幅提升性能，如果我们想进行文件拷贝，最快速的方法是把文件全部读取到内存再全部写出到目标地址，如</p>
<pre><code>FileInputStream fis = new FileInputStream(&quot;source.rar&quot;);
FileOutputStream fos = new FileOutputStream(&quot;copy.rar&quot;);
byte[] arr = new byte[fis.available()];        //获得文件大小做为字节数组
fis.read(arr);                                 //将文件上的所有字节读取到数组
fos.write(arr);                                //将数组中的所有字节一次写到文件上
fis.close();
fos.close();
</code></pre><p>因为这样就完成了最少的磁盘访问次数，所以 IO 性能很高，但是如果文件过大，就非常容易造成内存溢出。因此我们改进后的代码：  </p>
<pre><code>FileInputStream fis = new FileInputStream(&quot;source.rar&quot;);
FileOutputStream fos = new FileOutputStream(&quot;copy.rar&quot;);
int len;
byte[] arr = new byte[1024 * 8];               //自定义字节数组
while((len = fis.read(arr)) != -1) {
    fos.write(arr, 0, len);                    //写出字节数组的有效字节个数
}
fis.close();
fos.close();
</code></pre><p>Java 早已考虑到了 IO 性能问题，为了方便开发者，在 JDK1.0 IO 包下就有 BufferedInputStream 和 BufferedOutputStream 分别是 FilterInputStream 类和 FilterOutputStream 类的子类，实现了装饰设计模式。该流使用缓冲思想，内置一个缓冲区(数组)，BufferedInputStream 会一次从文件中读取 8192 个字节(默认构造)，存在缓冲区中，程序再次读取时直接从缓存区获取，避免访问磁盘；BufferedOutputStream 向流中写出文件也是先写到缓冲区中，直到缓冲区写满才一次性写到文件里。</p>
<pre><code>FileInputStream fis = new FileInputStream(&quot;source.rar&quot;);    //创建文件输入流对象,关联source.rar
BufferedInputStream bis = new BufferedInputStream(fis);     //创建缓冲区对fis装饰
FileOutputStream fos = new FileOutputStream(&quot;copy.rar&quot;);    //创建输出流对象,关联copy.rar
BufferedOutputStream bos = new BufferedOutputStream(fos);   //创建缓冲区对fos装饰
int b;
while((b = bis.read()) != -1) {        
    bos.write(b);
}
bis.close();                                                //关流只关装饰后的对象即可
bos.close();
</code></pre><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>设备 Samsung Galaxy J  Android4.4 内部存储空间  不同测试参数均取十次数据计算平均值<br>source.rar 约50mb 进行单次文件拷贝<br>BufferedInputStream 缩写 bis   BufferedOutputStream 缩写 bos<br>FileInputStream 缩写 fis  FileOutputStream 缩写 fos</p>
<p>方式一：</p>
<pre><code>while((b = bis.read()) != -1) {    
    bos.write(b);
}
</code></pre><p>  用时 32760ms-38593ms 平均 35628ms<br>  拷贝一个50mb的文件大约用了35秒！</p>
<p>方式二：</p>
<pre><code>byte[] arr = new byte[1024 * 8];            
while((len = fis.read(arr)) != -1) {
    fos.write(arr, 0, len);                    
}
</code></pre><p>  用时  622ms-661ms 平均 641.5ms<br>  没有使用缓冲流，自定义缓冲数组的方式，时间控制在一秒以内，比较正常。</p>
<p>方式三： </p>
<pre><code>byte[] arr = new byte[1024 * 8];        
while((len = bis.read(arr)) != -1) {
    fos.write(arr, 0, len);                    
}
</code></pre><p>  用时 614ms-687ms 平均 651.9md<br>  查看 bis.read(arr) 的源码，可以看出还是调用了 fis 的 read(b, off, len) 方法。和预期一致：性能几乎等同方式二，但是多创建了很多对象，造成了不必要的浪费。</p>
<p>方式四：</p>
<pre><code>while((b = fis.read()) != -1) {        
    bos.write(b);
}
</code></pre><p>  用时 1087411ms 约18分钟<br>  如果每个字节都进行 IO 操作，不增加缓冲数组，导致的性能下降是非常严重的。</p>
<p>结论：不难发现，以上四种方式中，第二种方式可以提供我们更好的性能，使用缓冲流在方式三中并没有提高效率，反而在方式一中会大大降低效率。<strong>我的个人观点是大多数情况下使用 java.io 都不需要用到 Buffered 类</strong>，我们可以先搞清楚 Buffered 类的原理，Buffered 的原理就是减少 IO，而我们可以通过简单的方式实现。Buffered 类会操作两个数组(输入流管理一个，输出流管理一个)，而我们自定义的数组只需要一个，节省了内存又提高了性能。</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>read() 方法读取的是一个字节,为什么返回是 int ,而不是 byte<br>因为字节输入流可以操作任意类型的文件,比如图片音频等,这些文件底层都是以二进制形式的存储的,如果每次读取都返回byte,有可能在读到中间的时候遇到 111111111 那么这 11111111 是 byte 类型的 -1,我们的程序是遇到 -1就会停止不读了,后面的数据就读不到了,所以在读取的时候用 int 类型接收,如果 11111111 会在其前面补上 24 个 0 凑足 4 个字节,那么 byte 类型的 -1 就变成 int 类型的 255 了这样可以保证整个数据读完,而结束标记的 -1 就是int类型</li>
<li>bis.read() 返回的是下一个字节 (the next byte of data) ，而 bis.read(b) 返回的是读取的长度 (the buffer into which the data is read)，如果还没读到文件结尾，该长度就是数组长度</li>
<li>fos.write(arr, 0, len); 不能替换为 fos.write(arr); 因为在最后一次 fis.read 读取时 len 不等于自定义字节数组的长度，就会导致文件末尾写入的数据错误，甚至文件损毁</li>
<li>如果输入的缓冲区和输出的缓冲区不是同一个数组，那也最好保证设置数组长度一致，否则会影响性能。请开发者减少不必要的缓冲流滥用。</li>
<li>byte[] arr = new byte[1024 * 8]; 自定义缓冲数组的大小，可以根据实际情况(大量碎片文件还是大文件传输等)调整，通常为1024 * 2的n次幂 </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，一次 IO 的代价是很高的，所以减少 IO 次数将会极大提升性能。提高文件读写性能，是每一位开发者都要考虑的，也是本文的核心目的，如果已经对 Java 中的 IO 流比较熟悉，可以直接拖到最后看结论。&lt;/p&gt;
&lt;h4 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h4&gt;&lt;p&gt;IO 流用来处理设备之间的数据传输，Java 对数据的操作是通过流的方式，用于操作流的类都在 IO 包内，按流向分为输入流，输出流；按流操作分为字节流，字符流，其中字节流可以操作任何数据，因为在计算机中任何数据都是以字节的形式存储，字符流只能操作纯字符数据，比较方便。字节流的抽象父类：InputStream，OutputStream；字符流的抽象父类：Reader，Writer。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://gallonyin.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Python 中那些知识点 [持续更新] [Python]</title>
    <link href="http://gallonyin.github.io/2017/02/27/Python%20Base/"/>
    <id>http://gallonyin.github.io/2017/02/27/Python Base/</id>
    <published>2017-02-27T13:15:00.000Z</published>
    <updated>2017-04-09T10:47:43.481Z</updated>
    
    <content type="html"><![CDATA[<p>本文是我在自学 Python 3.5 中遇到的一些知识梳理和一些技巧分享，Python 在简洁性、易读性以及可扩展性上优势明显，使用率呈线性增长，如果你想去学习一门新的设计语言或是开开眼界，那么我非常推荐你这个优美的能写出乐趣的语言 Python<br><a id="more"></a></p>
<h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = &apos;ABC&apos;</div><div class="line">b = a</div><div class="line">a = &apos;XYZ&apos;</div><div class="line">print(b)</div><div class="line">\# &apos;ABC&apos;    b = a 使 b 指向的&apos;ABC&apos;地址，所以 b 没有被修改</div></pre></td></tr></table></figure></p>
<p>转义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">\t 表示一个制表符</div><div class="line">\\ 表示 \ 字符本身</div><div class="line">r&apos;...&apos; 表示不需要转义 但不能表示多行也不能表示包含&apos; 和 &apos;&apos; 的字符串(可用 r&apos;&apos;&apos;...&apos;&apos;&apos; 解决)</div></pre></td></tr></table></figure></p>
<p>编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">如果中文字符串在 Python 环境下遇到 UnicodeDecodeError，这是因为 .py 文件保存的格式有问题。可以在第一行添加注释    </div><div class="line">解决方法为只要在文件开头加入 # -*- coding: UTF-8 -*- 或者 #coding=utf-8</div></pre></td></tr></table></figure></p>
<p>计算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">and or 均有短路计算(类似 Java 中 &amp;&amp; ||)</div><div class="line">因为Python把0、空字符串&apos;&apos;和None看成 False，其他数值和非空字符串都看成 True</div><div class="line">返回结果为计算终止项</div></pre></td></tr></table></figure></p>
<p>集合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">当索引数字为负数时，表示逆序读出 List 中的内容，记住 List 的最后一个空间的编号为 -1 开始</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">单元素 tuple 时有歧义，Python 规定，单元素 tuple 要多加一个逗号 &quot;,&quot;，t = (1,)，多元素 tuple 最后加不加 &quot;,&quot; 结果一样</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1. 有序集合：list，tuple，str和unicode；</div><div class="line">2. 无序集合：set</div><div class="line">3. 无序集合并且具有 key-value 对：dict</div></pre></td></tr></table></figure>
<p>网络<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">POST 请求下面必须加 &#123;% csrf_token %&#125; 否则403(安全) </div><div class="line">跨站请求伪造（英语：Cross-site request forgery）</div></pre></td></tr></table></figure></p>
<p>兼容 (Python 2 &amp; Python 3)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">urllib2-Python 官方基础模块  requests - 强大第三方包</div><div class="line">Python 3.x中 urllib 库和 urilib2 库合并成了 urllib 库</div><div class="line">其中 urllib2.urlopen() 变成了 urllib.request.urlopen()</div><div class="line">urllib2.Request() 变成了 urllib.request.Request()</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">去除了 &lt;&gt;，全部改用 != </div><div class="line">去除 ``，全部改用 repr() </div><div class="line">关键词加入 as 和 with，还有 True, False, None </div><div class="line">整型除法返回浮点数，要得到整型结果，请使用// </div><div class="line">加入 nonlocal 语句，使用noclocal x 可以直接指派外围（非全局）变量 </div><div class="line">去除 print 语句，加入 print() 函数实现相同的功能。同样的还有 exec 语句，已经改为 exec() 函数 </div><div class="line">改变了顺序操作符的行为，例如 x &lt; y ，当 x 和 y 类型不匹配时抛出 TypeError  而不是返回随机布尔值 </div><div class="line">输入函数改变了，删除了 raw_input，用 input 代替</div><div class="line">去除元组参数解包。不能 def(a, (b, c)):pass 这样定义函数了 </div><div class="line">Python3 字符串只有 str 一种类型，但它跟 2.x版本的 unicode 几乎一样</div><div class="line">Python3 去除了 long 类型</div><div class="line">大量模块变动</div></pre></td></tr></table></figure>
<p>内建函数 BIF(built-in functions)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">zip() 函数 可以把两个集合合并成一个集合</div><div class="line">zip([10,20,30], [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]) -&gt; [(10, &apos;a&apos;), (20, &apos;b&apos;), (30, &apos;c&apos;)]</div></pre></td></tr></table></figure></p>
<p>特殊方法(魔术方法)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">特殊方法定义在 class 中，不需要直接调用，某些函数或操作符会调用对应的特殊方法</div><div class="line">用于print的__str__(类似toString)  </div><div class="line">用于len的__len__</div><div class="line">用于cmp的__cmp__  (Py3中已经移除, 需要引入 operator 模块 operator.eq(a, b))</div><div class="line">直接调用实力对象 重写__call__</div><div class="line">__str__()用于显示给用户，而__repr__()用于显示给开发人员</div></pre></td></tr></table></figure></p>
<p>三方模块管理工具<br>    1.easy_install  2.pip 官方推荐,已内置到2.7.9</p>
<p>Exception<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">raise Exception(&quot;&quot;) (类似于 throw)</div></pre></td></tr></table></figure></p>
<p>Database<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Database API  </div><div class="line">https://www.python.org/dev/peps/pep-0249/ #官方接口规范 v2.0 </div><div class="line">访问数据库流程</div><div class="line">1.创建 connection 2.获取 cursor 3.执行命令/处理数据 4.关闭 cursor 5.关闭 connection</div><div class="line">connection 对象支持的方法 </div><div class="line">· cursor() # 使用该连接创建并返回游标</div><div class="line">· commit() # 提交当前事务</div><div class="line">· rollback() # 回滚当前事务</div><div class="line">· close() # 关闭连接</div><div class="line">事务: 访问和更新数据库的一个程序执行单元</div><div class="line">- 原子性：事务中包括的诸操作要么都做，要么都不做</div><div class="line">- 一致性：事务必须使数据库从一致性状态变到另一个一致性状态</div><div class="line">- 隔离性：一个事务的执行不能被其他事务干扰</div><div class="line">- 持久性：事务一旦提交，它对数据库的改变就是永久性的</div><div class="line">开发中使用事务</div><div class="line">· 关闭自动 commit: 设置 conn.autocommit(false) (mysql db 默认 false)</div><div class="line">· 正常结束事务: conn.commit()</div><div class="line">· 异常结束事务: conn.rollback()</div></pre></td></tr></table></figure></p>
<h4 id="Hacks-小技巧"><a href="#Hacks-小技巧" class="headerlink" title="Hacks 小技巧"></a>Hacks 小技巧</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int() 函数可以把字符串转换为整数  默认按十进制 第二参数 base=&apos;10&apos;</div><div class="line">中偏函数 int2 = functools.partial(int, base=2) #调用按二进制</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是我在自学 Python 3.5 中遇到的一些知识梳理和一些技巧分享，Python 在简洁性、易读性以及可扩展性上优势明显，使用率呈线性增长，如果你想去学习一门新的设计语言或是开开眼界，那么我非常推荐你这个优美的能写出乐趣的语言 Python&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://gallonyin.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>阻塞式队列的实现原理 BlockingQueue [Java]</title>
    <link href="http://gallonyin.github.io/2016/12/11/BlockingQueue/"/>
    <id>http://gallonyin.github.io/2016/12/11/BlockingQueue/</id>
    <published>2016-12-11T13:15:00.000Z</published>
    <updated>2017-04-09T10:47:35.460Z</updated>
    
    <content type="html"><![CDATA[<h4 id="阻塞式队列的实现方式"><a href="#阻塞式队列的实现方式" class="headerlink" title="阻塞式队列的实现方式"></a>阻塞式队列的实现方式</h4><p>首先，阻塞队列( BlockingQueue )是 Java util.concurrent 包下重要的数据结构。当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满；从阻塞队列取数据时，如果队列已空，线程将会阻塞等待直到队列非空。本文与 java 官方的阻塞式队列不同，自己以另一种方式(线程 wait / notifyAll )实现(原理相似)，本案 demo 遵循 FIFO (先进先出)原则，只写出了 put (阻塞)/ take (阻塞)方法，官方实现还含有 add / remove (失败抛出异常)、offer / poll (失败时返回值不同)、offer / poll (重载 增加 timeout 阻塞时间限制，并返回值是否成功)在这里都没有写出。除此之外 lock / condition 方式实现也附在文中最下方以供对比。本案 demo 使用 Android UI 但是只需懂得 java 基本语法，不会影响理解。<br><a id="more"></a></p>
<h4 id="相关应用-生产者消费者模式"><a href="#相关应用-生产者消费者模式" class="headerlink" title="相关应用:生产者消费者模式"></a>相关应用:生产者消费者模式</h4><p>为能够解决绝大多数并发问题，该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。当然，这不是这次要讲的重点，如果有兴趣可以去了解阻塞式队列处理高并发问题。</p>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>在等待 Condition 时，允许发生“虚假唤醒”，这通常作为对基础平台语义的让步。对于大多数应用程序，这带来的实际影响很小，因为 Condition  应该总是在一个循环中被等待，并测试正被等待的状态声明。某个实现可以随意移除可能的虚假唤醒，但建议应用程序程序员总是假定这些虚假唤醒可能发生，因此总是在一个循环中(如 while )等待。<br>三种形式的条件等待（可中断、不可中断和超时）在一些平台上的实现以及它们的性能特征可能会有所不同。尤其是它可能很难提供这些特性和维护特定语义，比如排序保证。更进一步地说，中断线程实际挂起的能力在所有平台上并不是总是可行的。因此，并不要求某个实现为所有三种形式的等待定义完全相同的保证或语义，也不要求其支持中断线程的实际挂起。要求实现清楚地记录每个等待方法提供的语义和保证，在某个实现不支持中断线程的挂起时，它必须遵从此接口中定义的中断语义。由于中断通常意味着取消，而又通常很少进行中断检查，因此实现可以先于普通方法的返回来对中断进行响应。即使出现在另一个操作后的中断可能会释放线程锁时也是如此。实现应记录此行为。 </p>
<p>demo 代码如下:</p>
<pre><code>package com.example.test.test;

import android.os.Bundle;
import android.support.v7.app.AppCompatActivity;
import android.util.Log;
import android.view.View;
import android.widget.TextView;

import java.util.LinkedList;
import java.util.Queue;

public class QueueActivity extends AppCompatActivity implements View.OnClickListener {
    private static final String TAG = &quot;QueueActivity&quot;;

    public int limit = 5; // 队列最大元素数

    public Queue&lt;Object&gt; queue = new LinkedList&lt;&gt;();

    private int putSleepCount = 0; // 入队 阻塞数量统计
    private int takeSleepCount = 0; // 出队 阻塞数量统计

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_queue);

        findViewById(R.id.bt_put).setOnClickListener(this);
        findViewById(R.id.bt_take).setOnClickListener(this);
    }

    private int put = -1; // 模拟每次入队的元素 0、1、2(依次增长)

    @Override
    public void onClick(View view) {
        int id = view.getId();
        if (id == R.id.bt_put) {
            put++;
            Log.e(TAG, &quot;put: &quot; + put);
            new Thread() {
                @Override
                public void run() {
                    put(put);
                }
            }.start();
            return;
        }
        if (id == R.id.bt_take) {
            new Thread() {
                @Override
                public void run() {
                    Object take = take();
                    Log.e(TAG, &quot;take: &quot; + take);
                }
            }.start();
        }
    }

    /**
     * 入队 如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行
     */
    private synchronized void put(Object obj) {
        while (queue.size() == limit) {
            try {
                putSleepCount++;
                Log.e(TAG, &quot;putSleepCount: &quot; + putSleepCount + &quot;&quot;);
                wait();
                putSleepCount--;
                Log.e(TAG, &quot;putSleepCount: &quot; + putSleepCount + &quot;&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        queue.add(obj);
        //如果添加一个元素后集合大小为1则应该唤醒阻塞的线程是否需要该元素出队(如果有阻塞)
        if (queue.size() == 1) {
            notifyAll();
        }
    }

    /**
     * 出队 如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行
     */
    private synchronized Object take() {
        while (queue.size() == 0) {
            try {
                takeSleepCount++;
                Log.e(TAG, &quot;takeSleepCount: &quot; + takeSleepCount + &quot;&quot;);
                wait();
                takeSleepCount--;
                Log.e(TAG, &quot;takeSleepCount: &quot; + takeSleepCount + &quot;&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        try {
            return queue.remove();
        } finally {
            //如果取出一个元素后集合大小=limit-1则应该唤醒阻塞的线程入队(如果有阻塞)
            if (queue.size() == limit - 1) {
                notifyAll();
            }
        }
    }
}
</code></pre><p>测试一： take 阻塞</p>
<pre><code>(调用一次 take 方法)
12-11 21:05:26.745 18459-15228/com.example.test.test E/QueueActivity: takeSleepCount: 1
因为队列为空 所以调用被阻塞 线程 wait
(接着调用一次 put 方法)
12-11 21:06:30.945 18459-18459/com.example.test.test E/QueueActivity: put: 0
12-11 21:06:30.945 18459-15228/com.example.test.test E/QueueActivity: takeSleepCount: 0
12-11 21:06:30.945 18459-15228/com.example.test.test E/QueueActivity: take: 0
从中可以看出 put 添加一个元素时会紧接着被取出
在多次阻塞 take 后 调用 put 仍可以有序取出元素 Log太多就不放了，可以自行测试
</code></pre><p>测试二： put 阻塞</p>
<pre><code>(调用六次 put 方法) (demo limit值为5)
12-11 21:09:21.205 18459-18459/com.example.test.test E/QueueActivity: put: 0
12-11 21:09:23.115 18459-18459/com.example.test.test E/QueueActivity: put: 1
12-11 21:09:23.625 18459-18459/com.example.test.test E/QueueActivity: put: 2
12-11 21:09:24.085 18459-18459/com.example.test.test E/QueueActivity: put: 3
12-11 21:09:24.475 18459-18459/com.example.test.test E/QueueActivity: put: 4
12-11 21:09:24.835 18459-18459/com.example.test.test E/QueueActivity: put: 5
12-11 21:09:24.835 18459-18855/com.example.test.test E/QueueActivity: putSleepCount: 1    
(接着调用一次 take 方法)
12-11 21:10:07.265 18459-18855/com.example.test.test E/QueueActivity: putSleepCount: 0
12-11 21:10:07.265 18459-19469/com.example.test.test E/QueueActivity: take: 0
从中可以看出 在达到 limit 值后 put 操作会被阻塞，而之后的 take 操作会唤醒所有的阻塞线程再次判断并加入队列
</code></pre><p>附：<br>使用 lock / condition 实现部分代码如下(JDK 1.7 ArrayBlockingQueue)：<br>​<br>    //构造方法<br>    public ArrayBlockingQueue(int capacity, boolean fair) {<br>            if (capacity &lt;= 0)<br>                throw new IllegalArgumentException();<br>            //创建数组<br>            this.items = new Object[capacity];<br>            //创建锁和阻塞条件<br>            lock = new ReentrantLock(fair);<br>            notEmpty = lock.newCondition();<br>            notFull =  lock.newCondition();<br>        }<br>    //添加元素的方法<br>    public void put(E e) throws InterruptedException {<br>            checkNotNull(e);<br>            final ReentrantLock lock = this.lock;<br>            lock.lockInterruptibly();<br>            try {<br>                while (count == items.length)<br>                    notFull.await();<br>                //如果队列不满就入队<br>                enqueue(e);<br>            } finally {<br>                lock.unlock();<br>            }<br>        }<br>     //入队的方法<br>     private void enqueue(E x) {<br>            final Object[] items = this.items;<br>            items[putIndex] = x;<br>            if (++putIndex == items.length)<br>                putIndex = 0;<br>            count++;<br>            notEmpty.signal();<br>        }<br>     //移除元素的方法<br>     public E take() throws InterruptedException {<br>            final ReentrantLock lock = this.lock;<br>            lock.lockInterruptibly();<br>            try {<br>                while (count == 0)<br>                    notEmpty.await();<br>                return dequeue();<br>            } finally {<br>                lock.unlock();<br>            }<br>        }<br>     //出队的方法<br>     private E dequeue() {<br>            final Object[] items = this.items;<br>            @SuppressWarnings(“unchecked”)<br>            E x = (E) items[takeIndex];<br>            items[takeIndex] = null;<br>            if (++takeIndex == items.length)<br>                takeIndex = 0;<br>            count–;<br>            if (itrs != null)<br>                itrs.elementDequeued();<br>            notFull.signal();<br>            return x;</p>
<p>这样做的优点是调用 notEmpty.signalAll()只会唤醒  notEmpty.await()下的线程，notFull 同理，但是通常不可能同时存在两种条件(入队和出队同时)阻塞。在 Condition 中，用 await()替换 wait()，用 signal()替换 notify()，用 signalAll()替换 notifyAll()，这里注意，Condition 是被绑定到 Lock 上的，要创建一个 Lock 的 Condition 必须用 newCondition()方法。<br>当然本文并不是为了比较两种实现方法的优劣，而且只要理解第一种就很容易理解第二种，本文只是通过 demo 让大家理解阻塞式队列的原理从而知道为什么使用它，或能对阻塞式队列多一点了解。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;阻塞式队列的实现方式&quot;&gt;&lt;a href=&quot;#阻塞式队列的实现方式&quot; class=&quot;headerlink&quot; title=&quot;阻塞式队列的实现方式&quot;&gt;&lt;/a&gt;阻塞式队列的实现方式&lt;/h4&gt;&lt;p&gt;首先，阻塞队列( BlockingQueue )是 Java util.concurrent 包下重要的数据结构。当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满；从阻塞队列取数据时，如果队列已空，线程将会阻塞等待直到队列非空。本文与 java 官方的阻塞式队列不同，自己以另一种方式(线程 wait / notifyAll )实现(原理相似)，本案 demo 遵循 FIFO (先进先出)原则，只写出了 put (阻塞)/ take (阻塞)方法，官方实现还含有 add / remove (失败抛出异常)、offer / poll (失败时返回值不同)、offer / poll (重载 增加 timeout 阻塞时间限制，并返回值是否成功)在这里都没有写出。除此之外 lock / condition 方式实现也附在文中最下方以供对比。本案 demo 使用 Android UI 但是只需懂得 java 基本语法，不会影响理解。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://gallonyin.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello Hexo</title>
    <link href="http://gallonyin.github.io/2016/11/30/Hello%20Hexo/"/>
    <id>http://gallonyin.github.io/2016/11/30/Hello Hexo/</id>
    <published>2016-11-30T14:46:22.000Z</published>
    <updated>2016-12-19T12:00:56.434Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
