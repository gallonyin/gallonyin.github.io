<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wonder Zone</title>
  <subtitle>A place full of miracles</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gallonyin.github.io/"/>
  <updated>2017-03-14T14:38:03.840Z</updated>
  <id>http://gallonyin.github.io/</id>
  
  <author>
    <name>Gallon Yin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BufferedInput/OutputStream 缓冲流性能测试 [Java]</title>
    <link href="http://gallonyin.github.io/2017/03/12/Buffered/"/>
    <id>http://gallonyin.github.io/2017/03/12/Buffered/</id>
    <published>2017-03-12T13:15:00.000Z</published>
    <updated>2017-03-14T14:38:03.840Z</updated>
    
    <content type="html"><![CDATA[<p>首先，一次 IO 的代价是很高的，所以减少 IO 次数将会极大提升性能。提高文件读写性能，是每一位开发者都要考虑的，也是本文的核心目的，如果已经对 Java 中的 IO 流比较熟悉，可以直接拖到最后看结论。</p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>IO 流用来处理设备之间的数据传输，Java 对数据的操作是通过流的方式，用于操作流的类都在 IO 包内，按流向分为输入流，输出流；按流操作分为字节流，字符流，其中字节流可以操作任何数据，因为在计算机中任何数据都是以字节的形式存储，字符流只能操作纯字符数据，比较方便。字节流的抽象父类：InputStream，OutputStream；字符流的抽象父类：Reader，Writer。</p>
<a id="more"></a>  
<h4 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h4><p>由于已知减少 IO 次数可以大幅提升性能，如果我们想进行文件拷贝，最快速的方法是把文件全部读取到内存再全部写出到目标地址，如</p>
<pre><code>FileInputStream fis = new FileInputStream(&quot;source.rar&quot;);
FileOutputStream fos = new FileOutputStream(&quot;copy.rar&quot;);
byte[] arr = new byte[fis.available()];        //获得文件大小做为字节数组
fis.read(arr);                                 //将文件上的所有字节读取到数组
fos.write(arr);                                //将数组中的所有字节一次写到文件上
fis.close();
fos.close();
</code></pre><p>因为这样就完成了最少的磁盘访问次数，所以 IO 性能很高，但是如果文件过大，就非常容易造成内存溢出。因此我们改进后的代码：  </p>
<pre><code>FileInputStream fis = new FileInputStream(&quot;source.rar&quot;);
FileOutputStream fos = new FileOutputStream(&quot;copy.rar&quot;);
int len;
byte[] arr = new byte[1024 * 8];               //自定义字节数组
while((len = fis.read(arr)) != -1) {
    fos.write(arr, 0, len);                    //写出字节数组的有效字节个数
}
fis.close();
fos.close();
</code></pre><p>Java 早已考虑到了 IO 性能问题，为了方便开发者，在 JDK1.0 IO 包下就有 BufferedInputStream 和 BufferedOutputStream 分别是 FilterInputStream 类和 FilterOutputStream 类的子类，实现了装饰设计模式。该流使用缓冲思想，内置一个缓冲区(数组)，BufferedInputStream 会一次从文件中读取 8192 个字节(默认构造)，存在缓冲区中，程序再次读取时直接从缓存区获取，避免访问磁盘；BufferedOutputStream 向流中写出文件也是先写到缓冲区中，直到缓冲区写满才一次性写到文件里。</p>
<pre><code>FileInputStream fis = new FileInputStream(&quot;source.rar&quot;);    //创建文件输入流对象,关联source.rar
BufferedInputStream bis = new BufferedInputStream(fis);     //创建缓冲区对fis装饰
FileOutputStream fos = new FileOutputStream(&quot;copy.rar&quot;);    //创建输出流对象,关联copy.rar
BufferedOutputStream bos = new BufferedOutputStream(fos);   //创建缓冲区对fos装饰
int b;
while((b = bis.read()) != -1) {        
    bos.write(b);
}
bis.close();                                                //关流只关装饰后的对象即可
bos.close();
</code></pre><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>设备 Samsung Galaxy J  Android4.4 内部存储空间  不同测试参数均取十次数据计算平均值<br>source.rar 约50mb 进行单次文件拷贝<br>BufferedInputStream 缩写 bis   BufferedOutputStream 缩写 bos<br>FileInputStream 缩写 fis  FileOutputStream 缩写 fos</p>
<p>方式一：</p>
<pre><code>while((b = bis.read()) != -1) {    
    bos.write(b);
}
</code></pre><p>  用时 32760ms-38593ms 平均 35628ms<br>  拷贝一个50mb的文件大约用了35秒！</p>
<p>方式二：</p>
<pre><code>byte[] arr = new byte[1024 * 8];            
while((len = fis.read(arr)) != -1) {
    fos.write(arr, 0, len);                    
}
</code></pre><p>  用时  622ms-661ms 平均 641.5ms<br>  没有使用缓冲流，自定义缓冲数组的方式，时间控制在一秒以内，比较正常。</p>
<p>方式三： </p>
<pre><code>byte[] arr = new byte[1024 * 8];        
while((len = bis.read(arr)) != -1) {
    fos.write(arr, 0, len);                    
}
</code></pre><p>  用时 614ms-687ms 平均 651.9md<br>  查看 bis.read(arr) 的源码，可以看出还是调用了 fis 的 read(b, off, len) 方法。和预期一致：性能几乎等同方式二，但是多创建了很多对象，造成了不必要的浪费。</p>
<p>方式四：</p>
<pre><code>while((b = fis.read()) != -1) {        
    bos.write(b);
}
</code></pre><p>  用时 1087411ms 约18分钟<br>  如果每个字节都进行 IO 操作，不增加缓冲数组，导致的性能下降是非常严重的。</p>
<p>结论：不难发现，以上四种方式中，第二种方式可以提供我们更好的性能，使用缓冲流在方式三中并没有提高效率，反而在方式一中会大大降低效率。<strong>我的个人观点是大多数情况下使用 java.io 都不需要用到 Buffered 类</strong>，我们可以先搞清楚 Buffered 类的原理，Buffered 的原理就是减少 IO，而我们可以通过简单的方式实现。Buffered 类会操作两个数组(输入流管理一个，输出流管理一个)，而我们自定义的数组只需要一个，节省了内存又提高了性能。</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>read() 方法读取的是一个字节,为什么返回是 int ,而不是 byte<br>因为字节输入流可以操作任意类型的文件,比如图片音频等,这些文件底层都是以二进制形式的存储的,如果每次读取都返回byte,有可能在读到中间的时候遇到 111111111 那么这 11111111 是 byte 类型的 -1,我们的程序是遇到 -1就会停止不读了,后面的数据就读不到了,所以在读取的时候用 int 类型接收,如果 11111111 会在其前面补上 24 个 0 凑足 4 个字节,那么 byte 类型的 -1 就变成 int 类型的 255 了这样可以保证整个数据读完,而结束标记的 -1 就是int类型</li>
<li>bis.read() 返回的是下一个字节 (the next byte of data) ，而 bis.read(b) 返回的是读取的长度 (the buffer into which the data is read)，如果还没读到文件结尾，该长度就是数组长度</li>
<li>fos.write(arr, 0, len); 不能替换为 fos.write(arr); 因为在最后一次 fis.read 读取时 len 不等于自定义字节数组的长度，就会导致文件末尾写入的数据错误，甚至文件损毁</li>
<li>如果输入的缓冲区和输出的缓冲区不是同一个数组，那也最好保证设置数组长度一致，否则会影响性能。请开发者减少不必要的缓冲流滥用。</li>
<li>byte[] arr = new byte[1024 * 8]; 自定义缓冲数组的大小，可以根据实际情况(大量碎片文件还是大文件传输等)调整，通常为1024 * 2的n次幂 </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，一次 IO 的代价是很高的，所以减少 IO 次数将会极大提升性能。提高文件读写性能，是每一位开发者都要考虑的，也是本文的核心目的，如果已经对 Java 中的 IO 流比较熟悉，可以直接拖到最后看结论。&lt;/p&gt;
&lt;h4 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h4&gt;&lt;p&gt;IO 流用来处理设备之间的数据传输，Java 对数据的操作是通过流的方式，用于操作流的类都在 IO 包内，按流向分为输入流，输出流；按流操作分为字节流，字符流，其中字节流可以操作任何数据，因为在计算机中任何数据都是以字节的形式存储，字符流只能操作纯字符数据，比较方便。字节流的抽象父类：InputStream，OutputStream；字符流的抽象父类：Reader，Writer。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>阻塞式队列的实现原理 BlockingQueue [Java]</title>
    <link href="http://gallonyin.github.io/2016/12/11/BlockingQueue/"/>
    <id>http://gallonyin.github.io/2016/12/11/BlockingQueue/</id>
    <published>2016-12-11T13:15:00.000Z</published>
    <updated>2016-12-13T14:33:42.760Z</updated>
    
    <content type="html"><![CDATA[<h4 id="阻塞式队列的实现方式"><a href="#阻塞式队列的实现方式" class="headerlink" title="阻塞式队列的实现方式"></a>阻塞式队列的实现方式</h4><p>首先，阻塞队列 ( BlockingQueue )是 Java util.concurrent 包下重要的数据结构。当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满；从阻塞队列取数据时，如果队列已空，线程将会阻塞等待直到队列非空。本文与 java 官方的阻塞式队列不同，自己以另一种方式(线程 wait / notifyAll )实现(原理相似)，本案 demo 遵循 FIFO (先进先出)原则，只写出了 put (阻塞)/ take (阻塞)方法，官方实现还含有 add / remove (失败抛出异常)、offer / poll (失败时返回值不同)、offer / poll (重载 增加 timeout 阻塞时间限制，并返回值是否成功)在这里都没有写出。除此之外 lock / condition 方式实现也附在文中最下方以供对比。本案 demo 使用 Android UI 但是只需懂得 java 基本语法，不会影响理解。<br><a id="more"></a></p>
<h4 id="相关应用-生产者消费者模式"><a href="#相关应用-生产者消费者模式" class="headerlink" title="相关应用:生产者消费者模式"></a>相关应用:生产者消费者模式</h4><p>为能够解决绝大多数并发问题，该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。当然，这不是这次要讲的重点，如果有兴趣可以去了解阻塞式队列处理高并发问题。</p>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>在等待 Condition 时，允许发生“虚假唤醒”，这通常作为对基础平台语义的让步。对于大多数应用程序，这带来的实际影响很小，因为 Condition  应该总是在一个循环中被等待，并测试正被等待的状态声明。某个实现可以随意移除可能的虚假唤醒，但建议应用程序程序员总是假定这些虚假唤醒可能发生，因此总是在一个循环中(如 while )等待。<br>三种形式的条件等待（可中断、不可中断和超时）在一些平台上的实现以及它们的性能特征可能会有所不同。尤其是它可能很难提供这些特性和维护特定语义，比如排序保证。更进一步地说，中断线程实际挂起的能力在所有平台上并不是总是可行的。因此，并不要求某个实现为所有三种形式的等待定义完全相同的保证或语义，也不要求其支持中断线程的实际挂起。要求实现清楚地记录每个等待方法提供的语义和保证，在某个实现不支持中断线程的挂起时，它必须遵从此接口中定义的中断语义。由于中断通常意味着取消，而又通常很少进行中断检查，因此实现可以先于普通方法的返回来对中断进行响应。即使出现在另一个操作后的中断可能会释放线程锁时也是如此。实现应记录此行为。 </p>
<p>demo 代码如下:</p>
<pre><code>package com.example.test.test;

import android.os.Bundle;
import android.support.v7.app.AppCompatActivity;
import android.util.Log;
import android.view.View;
import android.widget.TextView;

import java.util.LinkedList;
import java.util.Queue;

public class QueueActivity extends AppCompatActivity implements View.OnClickListener {
    private static final String TAG = &quot;QueueActivity&quot;;

    public int limit = 5; // 队列最大元素数

    public Queue&lt;Object&gt; queue = new LinkedList&lt;&gt;();

    private int putSleepCount = 0; // 入队 阻塞数量统计
    private int takeSleepCount = 0; // 出队 阻塞数量统计

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_queue);

        findViewById(R.id.bt_put).setOnClickListener(this);
        findViewById(R.id.bt_take).setOnClickListener(this);
    }

    private int put = -1; // 模拟每次入队的元素 0、1、2(依次增长)

    @Override
    public void onClick(View view) {
        int id = view.getId();
        if (id == R.id.bt_put) {
            put++;
            Log.e(TAG, &quot;put: &quot; + put);
            new Thread() {
                @Override
                public void run() {
                    put(put);
                }
            }.start();
            return;
        }
        if (id == R.id.bt_take) {
            new Thread() {
                @Override
                public void run() {
                    Object take = take();
                    Log.e(TAG, &quot;take: &quot; + take);
                }
            }.start();
        }
    }

    /**
     * 入队 如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行
     */
    private synchronized void put(Object obj) {
        while (queue.size() == limit) {
            try {
                putSleepCount++;
                Log.e(TAG, &quot;putSleepCount: &quot; + putSleepCount + &quot;&quot;);
                wait();
                putSleepCount--;
                Log.e(TAG, &quot;putSleepCount: &quot; + putSleepCount + &quot;&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        queue.add(obj);
        //如果添加一个元素后集合大小为1则应该唤醒阻塞的线程是否需要该元素出队(如果有阻塞)
        if (queue.size() == 1) {
            notifyAll();
        }
    }

    /**
     * 出队 如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行
     */
    private synchronized Object take() {
        while (queue.size() == 0) {
            try {
                takeSleepCount++;
                Log.e(TAG, &quot;takeSleepCount: &quot; + takeSleepCount + &quot;&quot;);
                wait();
                takeSleepCount--;
                Log.e(TAG, &quot;takeSleepCount: &quot; + takeSleepCount + &quot;&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        try {
            return queue.remove();
        } finally {
            //如果取出一个元素后集合大小=limit-1则应该唤醒阻塞的线程入队(如果有阻塞)
            if (queue.size() == limit - 1) {
                notifyAll();
            }
        }
    }
}
</code></pre><p>测试一： take 阻塞</p>
<pre><code>(调用一次 take 方法)
12-11 21:05:26.745 18459-15228/com.example.test.test E/QueueActivity: takeSleepCount: 1
因为队列为空 所以调用被阻塞 线程 wait
(接着调用一次 put 方法)
12-11 21:06:30.945 18459-18459/com.example.test.test E/QueueActivity: put: 0
12-11 21:06:30.945 18459-15228/com.example.test.test E/QueueActivity: takeSleepCount: 0
12-11 21:06:30.945 18459-15228/com.example.test.test E/QueueActivity: take: 0
从中可以看出 put 添加一个元素时会紧接着被取出
在多次阻塞 take 后 调用 put 仍可以有序取出元素 Log太多就不放了，可以自行测试
</code></pre><p>测试二： put 阻塞</p>
<pre><code>(调用六次 put 方法) (demo limit值为5)
12-11 21:09:21.205 18459-18459/com.example.test.test E/QueueActivity: put: 0
12-11 21:09:23.115 18459-18459/com.example.test.test E/QueueActivity: put: 1
12-11 21:09:23.625 18459-18459/com.example.test.test E/QueueActivity: put: 2
12-11 21:09:24.085 18459-18459/com.example.test.test E/QueueActivity: put: 3
12-11 21:09:24.475 18459-18459/com.example.test.test E/QueueActivity: put: 4
12-11 21:09:24.835 18459-18459/com.example.test.test E/QueueActivity: put: 5
12-11 21:09:24.835 18459-18855/com.example.test.test E/QueueActivity: putSleepCount: 1    
(接着调用一次 take 方法)
12-11 21:10:07.265 18459-18855/com.example.test.test E/QueueActivity: putSleepCount: 0
12-11 21:10:07.265 18459-19469/com.example.test.test E/QueueActivity: take: 0
从中可以看出 在达到 limit 值后 put 操作会被阻塞，而之后的 take 操作会唤醒所有的阻塞线程再次判断并加入队列
</code></pre><p>附：<br>使用 lock / condition 实现部分代码如下(JDK 1.7 ArrayBlockingQueue)：</p>
<pre><code>//构造方法
public ArrayBlockingQueue(int capacity, boolean fair) {
        if (capacity &lt;= 0)
            throw new IllegalArgumentException();
        //创建数组    
        this.items = new Object[capacity];
        //创建锁和阻塞条件
        lock = new ReentrantLock(fair);   
        notEmpty = lock.newCondition();
        notFull =  lock.newCondition();
    }
//添加元素的方法
public void put(E e) throws InterruptedException {
        checkNotNull(e);
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            while (count == items.length)
                notFull.await();
            //如果队列不满就入队
            enqueue(e);
        } finally {
            lock.unlock();
        }
    }
 //入队的方法
 private void enqueue(E x) {
        final Object[] items = this.items;
        items[putIndex] = x;
        if (++putIndex == items.length)
            putIndex = 0;
        count++;
        notEmpty.signal();
    }
 //移除元素的方法
 public E take() throws InterruptedException {
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            while (count == 0)
                notEmpty.await();
            return dequeue();
        } finally {
            lock.unlock();
        }
    }
 //出队的方法
 private E dequeue() {
        final Object[] items = this.items;
        @SuppressWarnings(&quot;unchecked&quot;)
        E x = (E) items[takeIndex];
        items[takeIndex] = null;
        if (++takeIndex == items.length)
            takeIndex = 0;
        count--;
        if (itrs != null)
            itrs.elementDequeued();
        notFull.signal();
        return x;
</code></pre><p>这样做的优点是调用 notEmpty.signalAll()只会唤醒  notEmpty.await()下的线程，notFull 同理，但是通常不可能同时存在两种条件(入队和出队同时)阻塞。在 Condition 中，用 await()替换 wait()，用 signal()替换 notify()，用 signalAll()替换 notifyAll()，这里注意，Condition 是被绑定到 Lock 上的，要创建一个 Lock 的 Condition 必须用 newCondition()方法。<br>当然本文并不是为了比较两种实现方法的优劣，而且只要理解第一种就很容易理解第二种，本文只是通过 demo 让大家理解阻塞式队列的原理从而知道为什么使用它，或能对阻塞式队列多一点了解。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;阻塞式队列的实现方式&quot;&gt;&lt;a href=&quot;#阻塞式队列的实现方式&quot; class=&quot;headerlink&quot; title=&quot;阻塞式队列的实现方式&quot;&gt;&lt;/a&gt;阻塞式队列的实现方式&lt;/h4&gt;&lt;p&gt;首先，阻塞队列 ( BlockingQueue )是 Java util.concurrent 包下重要的数据结构。当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满；从阻塞队列取数据时，如果队列已空，线程将会阻塞等待直到队列非空。本文与 java 官方的阻塞式队列不同，自己以另一种方式(线程 wait / notifyAll )实现(原理相似)，本案 demo 遵循 FIFO (先进先出)原则，只写出了 put (阻塞)/ take (阻塞)方法，官方实现还含有 add / remove (失败抛出异常)、offer / poll (失败时返回值不同)、offer / poll (重载 增加 timeout 阻塞时间限制，并返回值是否成功)在这里都没有写出。除此之外 lock / condition 方式实现也附在文中最下方以供对比。本案 demo 使用 Android UI 但是只需懂得 java 基本语法，不会影响理解。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello Hexo</title>
    <link href="http://gallonyin.github.io/2016/11/30/Hello%20Hexo/"/>
    <id>http://gallonyin.github.io/2016/11/30/Hello Hexo/</id>
    <published>2016-11-30T14:46:22.000Z</published>
    <updated>2016-12-19T12:00:56.434Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
